<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <meta name="generator" content="Hugo 0.49" />
  <meta name="author" content="Check King">

  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Merriweather:400,700%7cOpen&#43;Sans:400,400italic,700%7cRoboto&#43;Mono%25!%28EXTRA%20*hugolib.PageOutput=Page%28/post%29%29">
  <link rel="stylesheet" href="/styles.css">
  

  

  
  <link rel="alternate" href="https://checkking.github.io/post/index.xml" type="application/rss+xml" title="Check King&#39;s Blog">
  <link rel="feed" href="https://checkking.github.io/post/index.xml" type="application/rss+xml" title="Check King&#39;s Blog">
  

  <link rel="apple-touch-icon" sizes="180x180" href="/img/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon/favicon-16x16.png">
  <link rel="manifest" href="/img/favicon/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">

  <link rel="manifest" href="/site.webmanifest">
  <link rel="icon" type="image/png" href="/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/icon-192.png">

  <link rel="canonical" href="https://checkking.github.io/post/">

  <meta property="twitter:card" content="summary_large_image">
  
  <meta property="twitter:site" content="@">
  <meta property="twitter:creator" content="@">
  
  <meta property="og:site_name" content="Check King&#39;s Blog">
  <meta property="og:url" content="https://checkking.github.io/post/">
  <meta property="og:title" content="Posts | Check King&#39;s Blog">
  <meta property="og:locale" content="en-us">
  
  <meta property="og:updated_time" content="2017-05-01T21:07:16&#43;08:00">
  

  <title>Posts | Check King&#39;s Blog</title>

  

</head>
<body>

<style type="text/css">

.masthead-hero {
  background-image: url("https://checkking.github.io/img/hero.jpg");
}
</style>

<div class="masthead-hero"></div>


  <h1>Posts</h1>

  

  
  
  <div>
    <h2><a href="https://checkking.github.io/post/arch/rate_limitator/">接口流量控制</a></h2>
    <div class="post-style">
      
      背景 公有云的服务通常是将私有云的服务进行包装，并对外提供服务的，由于业务应用系统的负载能力有限，为了防止非预期的请求对系统压力过大而拖垮业务应用系统，需要对请求流量进行限速。
漏斗算法 漏桶(Leaky Bucket)算法思路很简单,水(请求)先进入到漏桶里,漏桶以一定的速度出水(接口有响应速率),当水流入速度过大会直接溢出(访问频率超过接口响应速率),然后就拒绝请求,可以看出漏桶算法能强行限制数据的传输速率。
 优点  可以让流量匀速通过，实现简单
 缺点  流量始终匀速输出，对于突发特性的流量支持地不好
 实现  用一个队列即可搞定，消费者线程匀速取出
令牌桶算法 令牌桶算法(Token Bucket)和 Leaky Bucket 效果一样但方向相反的算法,更加容易理解.随着时间流逝,系统会按恒定1/QPS时间间隔(如果QPS=100,则间隔是10ms)往桶里加入Token(想象和漏洞漏水相反,有个水龙头在不断的加水),如果桶已经满了就不再加了.新请求来临时,会各自拿走一个Token,如果没有Token可拿了就阻塞或者拒绝服务.
 优点  可以应对突发性的流量
 缺点  实现起来不是很容易
 实现  下面详细
通过redis实现令牌桶算法进行流量控制 流量控制项目  单个Ip访问速度限制  规则: reqs / seconds， 例如: 300 / 60, 表示每分钟最多允许300个请求，也就是平均每秒钟5个请求，但是我们可以允许流量的抖动，允许每5秒内有100个请求，这时，我们可以这样设定： 100 / 5, 两个规则加在一起就能满足两个要求了。
具体流程：
一个请求过来，对于每个规则构造key:
key = GLOBAL_PREFIX_FOR_REDIS + PREFIX_RATE_LIMIT + KEY_SPLIT_FLAG + request.getClientIp() + i;   判断redis中key对应的列表长度, 如果列表长度小于限制，则通过; 如果大于等于限制，首先判断最早加入列表的元素（time）时间和当前时间差是否大于perSecond， 如果是，则将最早的时间元素从redis中移除，并将当前时间元素加入redis，允许请求通过，而且标记上后续清理过期的时间项目。如果不允许通过，则抛出异常  // 统计是否封禁 for (int i = 0; maxRateLimitPerIps !
      
    </div>
  </div>
  
  <div>
    <h2><a href="https://checkking.github.io/post/arch/sample/">谈谈抽样试验</a></h2>
    <div class="post-style">
      
      背景 对于一些重要的产品，开发出的新功能往往需要真实流量进行验证才能知道这个功能带来的收益是好还是坏，比如图搜变现的策略rd想要在图搜wise端出游戏的一个广告banner，点击这个广告banner，会跳到一个下载中间页，我们最终的目的是要提高下载量，这就要评估一下哪种下载中间页会提高下载量，当然还有一些其他的评估指标。因此需要从整个流量中抽取两个小部分流量来做对比实验。怎么去分配流量，让不同流量走不同的逻辑就是抽样框架的主要任务。 还有FE开发了一种新的广告样式，需要确认这种样式会不会提高CTR。这些新策略，新样式的上线，都需要灰度发布，也就是小流量实验。
我们的广告模块也实现了一个实验框架，用于灰度发布，我分析一下这个实验框架的细节。
实验框架的整体流程 实验用户通过抽样平台上创建抽样试验，比如这个抽样试验要对流量按照uid进行划分，实验组需要流量为1%, 对照组所需流量为1%，如果现有所有流量层有按照cuid划分的，并且这一层上剩余流量充足，则在这一层上选取流量区间分配给实验组和对照组。
则可以将流量区间1000~1099分配给实验组，并创建一个新的sid加入配置，将1100~1199分配给对照组，并创建一个新的sid加入配置。
流量分配好之后，就可以在这个流量下面创建一些策略变量，比如在实验组中这个变量值为x,在对照组中，这个变量值为y（变量需要指定模块）。还可以加入一些过滤条件，对流量进行过滤。比如比如query不能在某个此表中。
实验创建好，并通过审核，准备上线。就会生成两类配置。一类是广告入口模块（midway）所使用的流量划分配置，模块根据这个配置，对请求打上sid列表。传递给下游模块。另外一类配置是各个模块使用的抽样变量配置。程序在运行的时候根据不同sid取得不同的变量值，走不同的逻辑。
配置是通过一个配置配送模块进行的, 各个模块热加载配置。
具体打sid的过程 midway拿到流量分配配置后，解析配置，layermanager将按层解析配置，按层管理各个layer, layer中包含各个抽样节点，比如sid 999的流量区间为start=0, end=999
而且每层的sid都是按照start排序的。后续一个请求hash得到的一个整数就可以按照二分查找。
一个请求过来之后，就会一层一层地去匹配sid，每层最多匹配一个。
查找变量过程 下游模块加载抽样变量配置，热加载，按照变量名组织:
struct SampleParam { uint32_t sid,; void* val; } std::unordered_map&lt;std::string, SampleParam&gt; sample_variables.  当代码要用到抽样变量时，先到sample_variable中查找，如果不到，则用默认值。
为了统计和评估，在日志中加入sid, 这样可以统计pv,ctr等信息。
流量切分 流量划分的粒度为0.1%， 我们将全部流量划分成10000等份，这样全部流量就是0~9999。对输入进行随机hash计算，可以将流量打散在全流量中。 流量可以按照以下几种方式来划分： 1) 按IP来进行划分(地域)  2) 按UID进行划分 3) 按cookie进行划分 4) 按query进行划分
首先将key对应的字符串用creat_sign_murmur64函数转成64位的整数，然后对10000取模，得到一个0~10000之间的整数。整个整数再去和各个抽样进行匹配，如果在某个抽样区间，则将请求打上对应的sid。
实现流量的分层 100%的流量很容易被用完，加入每个实验都需要10%的流量，这样同时只能做10个实验。而且有些实验要求更多的流量，比如有些实验要求在特定query下才走什么要的策略，假如只抽取1%的流量，这样再用这个流量进行query过滤，那就太少了，因此这类实验往往要求很多的流量，比如30%。这样势必会造成流量不够用的情况。
因此需要进行流量分层，将100%的流量正交成16个全流量，从逻辑上将实验流量变成原来的16倍。正交的意思是指第一层的某段很小的1%流量能够均匀地分散到其他层的100%上，而不是集中在其他层的某一段。 正交层之间几乎没有相互影响：
假如有实验1，有实验组exp_a和对照组control_a，各占流量1%,在第一层，第二层中有实验2，有实验组exp_a，占流量2%。如果不正交的话，导致实验1和实验2流量重叠，一个请求要么全部中实验一和实验二，要么全不中。这样两个实验就可能会相互影响了（即使两个实验不互斥）。如果保证正交的话，第一层实验1的流量均匀的落到第二层，这样就只有极少一部分流量落到实验2中的流量。
如果实验1和实验2互斥，比如都要在一个广告位上出广告，这样实验一和实验二必须都在同一层。
分层的实现是为不同层的creat_sign_murmur64函数设置不同的初始化种子字符串实现的，在创建层的时候为每个层分配一个全局唯一的id，作为层的初始化seed。具体代码如下：
ErrorCode calc_sample_ratio(const boost::any &amp;any_value, const std::string &amp;seed, double &amp;sample_ratio) { std::string val; if (boost_any_to_str(any_value, val) !
      
    </div>
  </div>
  
  <div>
    <h2><a href="https://checkking.github.io/post/cs/link/">硬连接和软连接</a></h2>
    <div class="post-style">
      
      背景 项目的nginx日志太多了，需要迁移到其他磁盘，另外一个同学采用软链的方式迁移到其他磁盘上，这样不影响现有程序。对于软链和硬连接概念上还是有些模糊，所以总结一下，直接抄Quora上的一个通俗的回答.
What is the difference between a hard link and a soft link? Have you ever given a thought to what happens when you store a file on your hard disk?
I will show you.
Let’s create a file first.
touch myfile cat &gt; myfile Hello, world!  cat file should display this text:
cat myfile Hello, world!  Where do you think myfile is stored?
An obvious and correct answer is your hard drive.
      
    </div>
  </div>
  
  <div>
    <h2><a href="https://checkking.github.io/post/nginx/nginx7/">一个简易的debug库设计与实现</a></h2>
    <div class="post-style">
      
      背景 最近项目上线了广告Offer按照ecpm等排序策略功能，上线之后经常被pm骚扰，因为他经常想查看为什么一个offer没有展示等问题，每次都要帮他查看线上日志，过程很痛苦，占用了大把时间。必须要改变这种现状。
debug的用途 便于线上case追踪用，分析程序执行的每个环节。
设计要点  debug信息的层级关系  为了很好地阅读debug信息，必须将debug信息很好地组织起来，比如一个请求来了，在后台执行的时候需要经过好几步，stage1, stage2,state3,&hellip;,其中stage1中又有好几步，我们可以把这些信息按照树的结构组织起来：
{ &quot;request&quot;: { &quot;ip&quot;: &quot;180.92.201.3&quot;, &quot;uri&quot;: &quot;/api/offer&quot;, &quot;network&quot;: &quot;wifi&quot;, &quot;debugid&quot;: &quot;8782399662&quot; }, &quot;process&quot;: { &quot;stage_readOffers&quot;: [ { &quot;offer_id&quot;: &quot;3142&quot;, &quot;type&quot;: &quot;aio&quot;, &quot;flags&quot;: { &quot;d&quot;: 1, &quot;x&quot;: false, &quot;ne&quot;: -1 } }, { &quot;offer_id&quot;: &quot;3142&quot;, &quot;type&quot;: &quot;aio&quot;, &quot;flags&quot;: { &quot;d&quot;: 1, &quot;x&quot;: false, &quot;ne&quot;: -1 } }, &hellip; ], &quot;stage_filterOffers&quot;: [ { &quot;offer_id&quot;: &quot;3142&quot;, &quot;type&quot;: &quot;aio&quot;, &quot;flags&quot;: { &quot;d&quot;: 1, &quot;x&quot;: false, &quot;ne&quot;: -1 } }, .
      
    </div>
  </div>
  
  <div>
    <h2><a href="https://checkking.github.io/post/nginx/nginx6/">nginx so_reuseport</a></h2>
    <div class="post-style">
      
    </div>
  </div>
  
  <div>
    <h2><a href="https://checkking.github.io/post/nginx/nginx5/">为什么nginx默认使用ET模式的epoll</a></h2>
    <div class="post-style">
      
    </div>
  </div>
  
  <div>
    <h2><a href="https://checkking.github.io/post/arch/nginx_event_module/">nginx事件模块分析</a></h2>
    <div class="post-style">
      
      整体流程分析 先列出event模块相关定义的:
static ngx_command_t ngx_events_commands[] = { { ngx_string(&quot;events&quot;), NGX_MAIN_CONF|NGX_CONF_BLOCK|NGX_CONF_NOARGS, ngx_events_block, 0, 0, NULL }, ngx_null_command }; static ngx_core_module_t ngx_events_module_ctx = { ngx_string(&quot;events&quot;), NULL, ngx_event_init_conf }; ngx_module_t ngx_events_module = { NGX_MODULE_V1, &amp;ngx_events_module_ctx, /* module context <em>/ ngx_events_commands, /</em> module directives <em>/ NGX_CORE_MODULE, /</em> module type <em>/ NULL, /</em> init master <em>/ NULL, /</em> init module <em>/ NULL, /</em> init process <em>/ NULL, /</em> init thread <em>/ NULL, /</em> exit thread <em>/ NULL, /</em> exit process <em>/ NULL, /</em> exit master */ NGX_MODULE_V1_PADDING };  在ngx_init_cycle函数中，有下面部分代码:
      
    </div>
  </div>
  
  <div>
    <h2><a href="https://checkking.github.io/post/arch/nginx_probs1/">线上nginx错误日志追查</a></h2>
    <div class="post-style">
      
      问题描述 线上机器有一台机器报警，说摸个url请求失败率达到25%，等到线上机器查看nginx错误日志，发现下面的滚屏；
2017/04/10 18:00:28 [alert] 2378#0: *35137710183 socket() failed (24: Too many open files) while connecting to upstream, client: 202.69.12.16, server: api.mobojoy.baidu.com, request: &quot;GET /index.php?r=adfb/list&amp;al=847dd82e152ec6ddeb104ba8439a684d&amp;l=06e298ac92c301027067eea9a540dff4&amp;p=48cfe1bbaabf62b82e4f979f4cbeb44f&amp;hp=com.dianxinos.dxbs&amp;lc=xiaobu_yz_gl_PRE_FREE&amp;sdk=49 HTTP/1.1&quot;, upstream: &quot;fastcgi://127.0.0.1:9000&quot;, host: &quot;&mdash;-&quot; 2017/04/10 18:00:29 [crit] 2378#0: accept4() failed (24: Too many open files)  并且查看各个进程占用fd的情况：
$ lsof -n|awk &lsquo;{print $2}&rsquo;|sort|uniq -c|sort -nr|more 10259 2378 7520 16505 4273 5091 2661 5098 2508 5093 2201 5084 2183 5089 2001 5117 1934 5095 1927 5105 1911 5108 1906 5104 1809 5100 1713 5082 1631 5106 1336 5102  第一列为占用fd数，第二列为进程id，第一行就是nginx进程.
      
    </div>
  </div>
  
  <div>
    <h2><a href="https://checkking.github.io/post/cs/rpc_load_balance/">Locality-aware load balancing</a></h2>
    <div class="post-style">
      
      概述 LALB全称Locality-aware load balancing，是一个能把请求及时、自动地送到延时最低的下游的负载均衡算法，特别适合混合部署环境。 LALB可以解决的问题： - 下游的机器配置不同，访问延时不同，round-robin和随机分流效果不佳。 - 下游服务和离线服务或其他服务混部，性能难以预测。 - 自动地把大部分流量送给同机部署的模块，当同机模块出问题时，再跨机器。 - 优先访问本机房服务，出问题时再跨机房。
背景 最常见的分流算法是round robin和随机。这两个方法的前提是下游的机器和网络都是类似的，但在目前的线上环境下，特别是混部的产品线中，已经很难成立，因为： - 每台机器运行着不同的程序组合，并伴随着一些离线任务，机器的可用资源在持续动态地变化着。 - 机器配置不同。 - 网络延时不同。
这些问题其实一直有，但往往被OP辛勤的机器监控和替换给隐藏了。框架层面也有过一些努力，比如我厂UB框架中的WeightedStrategy是根据下游的cpu占用率来进行分流，但明显地它解决不了延时相关的问题，甚至cpu的问题也解决不了：因为它被实现为定期reload一个权值列表，可想而知更新频率高不了，等到负载均衡反应过来，一大堆请求可能都超时了。并且这儿有个数学问题：怎么把cpu占用率转为权值。假设下游差异仅仅由同机运行的其他程序导致，机器配置和网络完全相同，两台机器权值之比是cpu idle之比吗？假如是的，当我们以这个比例给两台机器分流之后，它们的cpu idle应该会更接近对吧？而这会导致我们的分流比例也变得接近，从而使两台机器的cpu idle又出现差距。你注意到这个悖论了吗？这些因素使得这类算法的实际效果和那两个基本算法没什么差距，甚至更差，用者甚少。
我们需要一个能自适应下游负载、规避慢节点的通用分流算法。
Locality-aware Locality-aware load balancing，能根据下游节点的负载分配流量，还能快速规避失效的节点，在很大程度上，这种算法的延时也是全局最优的。基本原理非常简单：
以下游节点的吞吐除以延时作为分流权值。  比如只有两台下游节点，W代表权值，QPS代表吞吐，L代表延时，那么W1 = QPS1 / L1和W2 = QPS2 / L2分别是这两个节点的分流权值，分流时随机数落入的权值区间就是流量的目的地了。
一种分析方法如下：
 稳定状态时的QPS显然和其分流权值W成正比，即W1 / W2 ≈ QPS1 / QPS2。 根据分流公式又有：W1 / W2 = QPS1 / QPS2 * (L2 / L1)。  故稳定状态时L1和L2应当是趋同的。当L1小于L2时，节点1会更获得相比其QPS1更大的W1，从而在未来获得更多的流量，直到其延时高于平均值或没有更多的流量。
注意这个算法并不是按照延时的比例来分流，不是说一个下游30ms，另一个60ms，它们的流量比例就是60 / 30。而是30ms的节点会一直获得流量直到它的延时高于60ms，或者没有更多流量了。以下图为例，曲线1和曲线2分别是节点1和节点2的延时与吞吐关系图，随着吞吐增大延时会逐渐升高，接近极限吞吐时，延时会飙升。左下的虚线标记了QPS=400时的延时，此时虽然节点1的延时有所上升，但还未高于节点2的基本延时（QPS=0时的延时），所以所有流量都会分给节点1，而不是按它们基本延时的比例（图中大约2:1）。当QPS继续上升达到1600时，分流比例会在两个节点延时相等时平衡，图中为9 : 7。很明显这个比例是高度非线性的，取决于不同曲线的组合，和单一指标的比例关系没有直接关联。在真实系统中，延时和吞吐的曲线也在动态变化着，分流比例更加动态。
      
    </div>
  </div>
  
  <div>
    <h2><a href="https://checkking.github.io/post/mind/tech_road/">读《技术人员的发展之路》之感</a></h2>
    <div class="post-style">
      
    </div>
  </div>
  

</div>
<div class="page_footer">
	<p>&copy; Check King 2018. Powered by <a href="http://gohugo.io/">Hugo</a> and <a href="https://github.com/jhu247/minimal-academic">Minimal Academic</a>.</p>
</div>
    
    


  </body>
</html>
