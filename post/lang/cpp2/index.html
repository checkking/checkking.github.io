<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  lang="en-us">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>谈谈enable_shared_from_this | My New Hugo Site</title>

<meta property='og:title' content='谈谈enable_shared_from_this - My New Hugo Site'>
<meta property='og:description' content='以前都没有用过enable_shared_from_this模板类，虽然经常遇到但是也没怎么去关注，今天抽时间好好学习了下enable_shared_from_this模板类，发现在使用shared_ptr模板类和enable_shared_from_this模板类时有许多陷阱的，故记录于此。
什么时候该使用enable_shared_from_this模板类 在看下面的例子之前，简单说下使用背景，单有一个类，某个函数需要返回当前对象的指针，我们返回的是shared_ptr，为什么使用智能指针呢，这是因为：当我们使用智能指针管理资源时，必须统一使用智能指针，而不能再某些地方使用智能指针，某些地方使用原始指针，否则不能保持智能指针的语义，从而产生各种错误。好了，介绍完背景，看下面的一段小程序：
#include &lt;iostream&gt; #include &lt;boost/shared_ptr.hpp&gt; class Test { public: //析构函数 ~Test() { std::cout &lt;&lt; &quot;Test Destructor.&quot; &lt;&lt; std::endl; } //获取指向当前对象的指针 boost::shared_ptr&lt;Test&gt; GetObject() { boost::shared_ptr&lt;Test&gt; pTest(this); return pTest; } }; int main(int argc, char *argv[]) { { boost::shared_ptr&lt;Test&gt; p( new Test( )); boost::shared_ptr&lt;Test&gt; q = p-&gt;GetObject(); } return 0; }  程序输出：
Test Destructor. Test Destructor.  从上面的输出你发现了什么，很明显的发现只创建new了一个Test对象，但是却调用了两次析构函数，这对程序来说肯定是一个灾难。为什么会出现这种情况呢？main函数中的boost::shared_ptr&lt;Test&gt; p( new Test( )); 将shared_ptr中引用计数器的值设置为1，而在GetObject函数中又通过boost::shared_ptr&lt;Test&gt; pTest(this)又将shared_ptr中的引用计数器的值增加了1，故在析构时一个Test对象被析构了两次。即产生这个错误的原因是通过同一个Test指针对象创建了多个shared_ptr，这是绝对禁止的。同时这也提醒我们在使用shared_ptr时一定不能通过同一个指针对象创建一个以上的shared_ptr对象。那么有什么方法从一个类的成员函数中获取当前对象的shared_ptr呢，其实方法很简单：只需要该类继承至enable_shared_from_this模板类,然后在需要shared_prt的地方调用enable_shared_from_this模板类的成员函数shared_from_this()即可，下面是改进后的代码：
#include &lt;iostream&gt; #include &lt;boost/enable_shared_from_this.hpp&gt; #include &lt;boost/shared_ptr.'>
<meta property='og:url' content='https://checkking.github.io/post/lang/cpp2/'>
<meta property='og:site_name' content='My New Hugo Site'>
<meta property='og:type' content='article'><meta property='og:image' content='https://www.gravatar.com/avatar/7f737ec3d15ee739b2bec7984b64a268?s=256'><meta property='article:section' content='Post'><meta property='article:published_time' content='2017-02-28T21:07:16&#43;08:00'/><meta property='article:modified_time' content='2017-02-28T21:07:16&#43;08:00'/><meta name='twitter:card' content='summary'><meta name='twitter:site' content='@'><meta name='twitter:creator' content='@'>

<link href="https://checkking.github.io/index.xml" rel="alternate" type="application/rss+xml" title="My New Hugo Site" />

<link rel="stylesheet" href="/css/style.css"/><link rel='stylesheet' href='https://checkking.github.io/css/custom.css'><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
</head>
<body>
<section class="section">
  <div class="container">
    <nav class="nav">
      <div class="nav-left">
        <a class="nav-item" href="https://checkking.github.io/"><h1 class="title is-4">My New Hugo Site</h1></a>
      </div>
      <div class="nav-right">
        <nav class="nav-item level is-mobile"><a class="level-item" aria-label="email" href='mailto:checkking@foxmail.com' target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/>
    <polyline points="22,6 12,13 2,6"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="github" href='https://github.com/checkking' target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="rss" href='/index.xml' target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle>
    
  </svg></i>
            </span>
          </a></nav>
      </div>
    </nav>

    <nav class="nav">
      

      
    </nav>

  </div>
</section>

<section class="section">
  <div class="container">
    <div class="subtitle tags is-6 is-pulled-right">
      
    </div>
    <h2 class="subtitle is-6">February 28, 2017</h2>
    <h1 class="title">谈谈enable_shared_from_this</h1>
    
    <div class="content">
      

<p>以前都没有用过enable_shared_from_this模板类，虽然经常遇到但是也没怎么去关注，今天抽时间好好学习了下enable_shared_from_this模板类，发现在使用shared_ptr模板类和enable_shared_from_this模板类时有许多陷阱的，故记录于此。</p>

<h4 id="什么时候该使用enable-shared-from-this模板类">什么时候该使用enable_shared_from_this模板类</h4>

<p>在看下面的例子之前，简单说下使用背景，单有一个类，某个函数需要返回当前对象的指针，我们返回的是shared_ptr，为什么使用智能指针呢，这是因为：当我们使用智能指针管理资源时，必须统一使用智能指针，而不能再某些地方使用智能指针，某些地方使用原始指针，否则不能保持智能指针的语义，从而产生各种错误。好了，介绍完背景，看下面的一段小程序：</p>

<pre><code class="language-c">#include &lt;iostream&gt;
#include &lt;boost/shared_ptr.hpp&gt;
class Test
{
    public:
        //析构函数
        ~Test() { std::cout &lt;&lt; &quot;Test Destructor.&quot; &lt;&lt; std::endl; }
        //获取指向当前对象的指针
        boost::shared_ptr&lt;Test&gt; GetObject()
        {
            boost::shared_ptr&lt;Test&gt; pTest(this);
            return pTest;
        }
};
int main(int argc, char *argv[])
{
    {
        boost::shared_ptr&lt;Test&gt; p( new Test( ));
        boost::shared_ptr&lt;Test&gt; q = p-&gt;GetObject();
    }
    return 0;
}
</code></pre>

<p>程序输出：</p>

<pre><code class="language-bash">Test Destructor.
Test Destructor.
</code></pre>

<p>从上面的输出你发现了什么，很明显的发现只创建new了一个Test对象，但是却调用了两次析构函数，这对程序来说肯定是一个灾难。为什么会出现这种情况呢？main函数中的<code>boost::shared_ptr&lt;Test&gt; p( new Test( ));</code> 将shared_ptr中引用计数器的值设置为1，而在GetObject函数中又通过<code>boost::shared_ptr&lt;Test&gt; pTest(this)</code>又将shared_ptr中的引用计数器的值增加了1，故在析构时一个Test对象被析构了两次。即产生这个错误的原因是通过同一个Test指针对象创建了多个shared_ptr，这是绝对禁止的。同时这也提醒我们在使用shared_ptr时一定不能通过同一个指针对象创建一个以上的shared_ptr对象。那么有什么方法从一个类的成员函数中获取当前对象的shared_ptr呢，其实方法很简单：只需要该类继承至enable_shared_from_this模板类,然后在需要shared_prt的地方调用enable_shared_from_this模板类的成员函数shared_from_this()即可，下面是改进后的代码：</p>

<pre><code class="language-c">#include &lt;iostream&gt;
#include &lt;boost/enable_shared_from_this.hpp&gt;
#include &lt;boost/shared_ptr.hpp&gt;
class Test : public boost::enable_shared_from_this&lt;Test&gt;
{
    public:
        //析构函数
        ~Test() { std::cout &lt;&lt; &quot;Test Destructor.&quot; &lt;&lt; std::endl; }
        //获取指向当前对象的指针
        boost::shared_ptr&lt;Test&gt; GetObject()
        {
            return shared_from_this();      //改进2
        }
};
int main(int argc, char *argv[])
{
    {
        boost::shared_ptr&lt;Test&gt; p( new Test( ));
        boost::shared_ptr&lt;Test&gt; q = p-&gt;GetObject();
    }
    return 0;
}
</code></pre>

<p>程序输出：</p>

<pre><code class="language-bash">Test Destructor.
</code></pre>

<p>从输出对象只被析构了一次，这是我们想要的结果，因此enable_shared_from_this模板类的作用是：用来作为一个基类，它允许从一个成员函数中获得一个当前对象的shared_ptr。那么enable_shared_from_this模板类到底是如何工作的了？请看下文分解~</p>

<h4 id="enable-shared-from-this模板类实现">enable_shared_from_this模板类实现</h4>

<p>打开enable_shared_from_this.hpp文件，会发现enable_shared_from_this模板类的实现如下：</p>

<pre><code class="language-c">template&lt;class T&gt; class enable_shared_from_this
{
    protected:
        enable_shared_from_this() BOOST_NOEXCEPT
        {
        }
        enable_shared_from_this(enable_shared_from_this const &amp;) BOOST_NOEXCEPT
        {
        }
        enable_shared_from_this &amp; operator=(enable_shared_from_this const &amp;) BOOST_NOEXCEPT
        {
            return *this;
        }
        ~enable_shared_from_this() BOOST_NOEXCEPT // ~weak_ptr&lt;T&gt; newer throws, so this call also must not throw
        {
        }
    public:
        shared_ptr&lt;T&gt; shared_from_this()
        {
            shared_ptr&lt;T&gt; p( weak_this_ );
            BOOST_ASSERT( p.get() == this );
            return p;
        }
        shared_ptr&lt;T const&gt; shared_from_this() const
        {
            shared_ptr&lt;T const&gt; p( weak_this_ );
            BOOST_ASSERT( p.get() == this );
            return p;
        }
    public: // actually private, but avoids compiler template friendship issues
        // Note: invoked automatically by shared_ptr; do not call
        template&lt;class X, class Y&gt; void _internal_accept_owner( shared_ptr&lt;X&gt; const * ppx, Y * py ) const
        {
            if( weak_this_.expired() )
            {
                weak_this_ = shared_ptr&lt;T&gt;( *ppx, py );
            }
        }
    private:
        mutable weak_ptr&lt;T&gt; weak_this_;
};
</code></pre>

<p>从enable_shared_from_this模板类的实现文件中我们可以很容易的发现我们只能使用返回shared_ptr的shared_from_this()和返回shared_ptr的shared_from_this()，因为这两个版本的shared_from_this()是public权限的，还有一个public权限的是internal_accept_owner函数，但是注释中已经明显指出不能调用这个函数，这个函数会被shared_ptr自动调用，internal_accept_owner函数用来初始化enable_shared_from_this模板类中的唯一成员变量weak_ptr weak_this。而shared_from_this()中是通过将weak_ptr
weak_this转化成shared_ptr和shared_ptr来返回的，因此在使用shared_from_this()之前需要先初始化weak_ptr weak_this对象，而weak_ptr weak_this对象是在_internal_accept_owner函数中进行的初始化，也就是说先需要创建shared_ptr对象。即在使用shared_from_this()函数之前，应该先初始化对象的基类enable_shared_from_this,接着再初始化对象，最后初始化shared_ptr。正因为有这个特点所以会出现以下常见的错误：</p>

<h4 id="使用enable-shared-from-this常见错误">使用enable_shared_from_this常见错误</h4>

<p>先来看情形1：</p>

<pre><code class="language-c">class Test : public boost::enable_shared_from_this&lt;Test&gt;
{
        Test() { boost::shared_ptr&lt;Test&gt; pTest = shared_from_this(); }
};
</code></pre>

<p>这种用法明显是错的，虽然对象的基类enable_shared_from_this类的构造函数已经被调用，但是shared_ptr的构造函数并没有被调用，因此weak_ptr weak_this_并没有被初始化，所以这时调用shared_from_this()是错误的。</p>

<p>接着我们来看情形2：</p>

<pre><code class="language-c">class Test : public boost::enable_shared_from_this&lt;Test&gt;
{
    void func() { boost::shared_ptr&lt;Test&gt; pTest = shared_from_this(); }
};
int main()
{
    Test test;
    test.func();    //错误
    Test pTest = new Test;
    pTest-&gt;func(); //错误
}
</code></pre>

<p>同样这种做法也是错误的，和情形1同样的原因shared_ptr的构造函数并没有被调用，因此weak_ptr weak_this_并没有被初始化。</p>

<p>正确的做法应该是：</p>

<pre><code class="language-c">class Test : public boost::enable_shared_from_this&lt;Test&gt;
{
    void func() { boost::shared_ptr&lt;Test&gt; pTest = shared_from_this(); }
};
int main()
{
    shared_ptr&lt;Test&gt; pTest( new Test() );
    pTest-&gt;func();
}
</code></pre>

<p><code>shared_ptr&lt;Test&gt; pTest(new Test());</code>这句话依次执行的顺序是：1 调用enable_shared_from_this的构造函数。2 调用Test的构造函数。 3 调用shared_ptr的构造函数初始化weak_ptr weak_this_。最后才能通过func()函数使用shared_from_this函数。</p>

<p>从上面的错误中我们知道在使用enable_shared_from_this类中的shared_from_this()函数时应该注意：
1. 不能在对象的构造函数中使用shared_from_this()函数。
2. 先需要调用enable_shared_from_this类的构造函数，接着调用对象的构造函数，最后需要调用shared_ptr类的构造函数初始化enable_shared_from_this的成员变量weak_this_。然后才能使用shared_from_this()函数。
3. 如何程序中使用了智能指针shared_ptr,则程序中统一使用智能指针，不能使用原始指针，以免出现错误。</p>

<h4 id="参考">参考</h4>

<ol>
<li><a href="http://www.boost.org/doc/libs/1_60_0/libs/smart_ptr/enable_shared_from_this.html" target="_blank">enable_shared_from_this</a></li>
<li><a href="https://www.reddit.com/r/cpp/comments/1jjlk4/safely_using_enable_shared_from_this/" target="_blank">Safely using enable_shared_from_this</a></li>
</ol>

      
      <div class="related">
</div>
      
    </div>
    
  </div>
</section>

<section class="section">
  <div class="container">
    <aside><div id="disqus_thread"></div></aside>
    <script type="text/javascript">
      var disqus_shortname = 'checkking';
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
  </div>
</section>


<section class="section">
  <div class="container has-text-centered">
    <p>&copy; <a href="https://github.com/checkking">checkking</a> 2018</p>
    
      <p>Powered by <a href="https://gohugo.io/">Hugo</a> &amp; <a href="https://github.com/ribice/kiss">Kiss</a>.</p>
    
  </div>
</section>

<script type="text/javascript">
  var _paq = _paq || [];
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="\/\/matomo.example.com\/";
    _paq.push(['setTrackerUrl', u+'piwik.php']);
    _paq.push(['setSiteId', '1']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'piwik.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<noscript>
  <img src="//matomo.example.com/piwik.php?idsite=1&amp;rec=1" style="border:0" alt="" />
</noscript>


</body>
</html>

